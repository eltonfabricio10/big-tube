# Estrutura de módulos proposta:
# bigtube/
#   __init__.py
#   main.py
#   app.py
#   window.py
#   download_manager.py
#   settings.py
#   utils.py
#   ui/
#     __init__.py
#     download_row.py
#     settings_dialog.py

# Módulo __init__.py
"""
BigTube - Um aplicativo para download de vídeos baseado em yt-dlp
"""

__version__ = "1.0.0"
__author__ = "Seu Nome"

# Módulo main.py
"""
Ponto de entrada principal para o aplicativo BigTube
"""
import sys
import gi

# Verifica dependências
try:
    import yt_dlp
except ImportError:
    print("Erro: yt-dlp não está instalado. Por favor, instale usando:")
    print("pip install yt-dlp")
    sys.exit(1)

# Verifica versões requeridas do GTK
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
gi.require_version('Gst', '1.0')
from gi.repository import Gst

# Inicializa GStreamer
Gst.init(None)

# Importa o aplicativo principal
from bigtube.app import BigTubeApp

def main():
    """Função principal para iniciar o aplicativo"""
    app = BigTubeApp()
    return app.run(sys.argv)

if __name__ == "__main__":
    sys.exit(main())

# Módulo app.py
"""
Implementação da classe de aplicativo principal
"""
import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Adw, Gio

from bigtube.window import BigTubeWindow

class BigTubeApp(Adw.Application):
    """Classe principal do aplicativo BigTube"""

    def __init__(self):
        super().__init__(application_id="com.example.bigtube",
                         flags=Gio.ApplicationFlags.FLAGS_NONE)
        self.create_actions()

    def do_activate(self):
        """Chamado quando o aplicativo é ativado"""
        win = self.props.active_window
        if not win:
            win = BigTubeWindow(self)
        win.present()

    def create_actions(self):
        """Cria as ações globais do aplicativo"""
        # Ação Sobre
        about_action = Gio.SimpleAction.new("about", None)
        about_action.connect("activate", self.on_about)
        self.add_action(about_action)

        # Ação Sair
        quit_action = Gio.SimpleAction.new("quit", None)
        quit_action.connect("activate", self.on_quit)
        self.add_action(quit_action)

    def on_about(self, action, param):
        """Mostra a janela Sobre"""
        about = Adw.AboutWindow(
            transient_for=self.props.active_window,
            application_name="BigTube",
            application_icon="video-x-generic",
            developer_name="Seu Nome",
            version="1.0",
            developers=["Seu Nome <seu.email@exemplo.com>"],
            copyright="© 2025",
            license_type=Gtk.License.GPL_3_0,
            website="https://github.com/seuusuario/bigtube",
            issue_url="https://github.com/seuusuario/bigtube/issues"
        )
        about.present()

    def on_quit(self, action, param):
        """Encerra o aplicativo"""
        self.quit()

# Módulo utils.py
"""
Funções e classes utilitárias para o BigTube
"""
import os
import sys
import re
import subprocess
import tempfile
import threading
import shutil
import uuid
import urllib.parse
from pathlib import Path
from datetime import datetime

import gi
gi.require_version('Gst', '1.0')
from gi.repository import Gst, GLib

class DownloadLogger:
    """Logger personalizado para capturar o progresso do download"""

    def __init__(self):
        self.callback = None
        self.error_callback = None

    def debug(self, msg):
        """Captura mensagens de debug, especialmente progresso de download"""
        if msg.startswith('[download]'):
            match = re.search(r'\b(\d+\.\d+)%', msg)
            if match:
                percentage = float(match.group(1))
                if hasattr(self, 'callback') and self.callback:
                    self.callback(percentage)

    def info(self, msg):
        """Captura mensagens informativas"""
        pass

    def warning(self, msg):
        """Captura mensagens de aviso"""
        if hasattr(self, 'warning_callback') and self.warning_callback:
            self.warning_callback(msg)

    def error(self, msg):
        """Captura mensagens de erro"""
        if hasattr(self, 'error_callback') and self.error_callback:
            self.error_callback(msg)

def validate_url(url):
    """Valida se a string é uma URL válida"""
    try:
        result = urllib.parse.urlparse(url)
        return all([result.scheme, result.netloc])
    except:
        return False

def sanitize_filename(filename):
    """Sanitiza um nome de arquivo removendo caracteres inválidos"""
    # Remove caracteres não permitidos em sistemas de arquivos
    invalid_chars = r'[<>:"/\\|?*]'
    sanitized = re.sub(invalid_chars, '_', filename)

    # Limita o tamanho do nome de arquivo
    if len(sanitized) > 200:
        base, ext = os.path.splitext(sanitized)
        sanitized = base[:196] + ext

    return sanitized

def generate_unique_filename(directory, basename, extension):
    """Gera um nome de arquivo único se já existir um com o mesmo nome"""
    original = os.path.join(directory, f"{basename}.{extension}")

    if not os.path.exists(original):
        return original

    # Se já existe, adiciona um timestamp
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    return os.path.join(directory, f"{basename}_{timestamp}.{extension}")

def check_disk_space(directory, required_mb=500):
    """Verifica se há espaço suficiente em disco"""
    try:
        if sys.platform == 'win32':
            free_bytes = shutil.disk_usage(directory).free
        else:
            stats = os.statvfs(directory)
            free_bytes = stats.f_frsize * stats.f_bavail

        free_mb = free_bytes / (1024 * 1024)
        return free_mb >= required_mb
    except Exception:
        # Em caso de erro, assumimos que há espaço suficiente
        return True

def play_notification_sound():
    """Toca um som de notificação"""
    try:
        # Usa GStreamer para tocar um som
        player = Gst.ElementFactory.make("playbin", "player")

        # Define um som de notificação dependendo da plataforma
        if sys.platform == 'linux':
            # Sons comuns em sistemas Linux
            sound_paths = [
                "/usr/share/sounds/freedesktop/stereo/complete.oga",
                "/usr/share/sounds/ubuntu/stereo/dialog-information.ogg",
                "/usr/share/sounds/gnome/default/alerts/complete.ogg"
            ]

            for sound_path in sound_paths:
                if os.path.exists(sound_path):
                    player.set_property("uri", f"file://{sound_path}")
                    player.set_state(Gst.State.PLAYING)
                    break
        elif sys.platform == 'win32':
            # No Windows, usa o som de notificação padrão via comando
            subprocess.Popen(['powershell', '-c', "(New-Object Media.SoundPlayer 'C:\\Windows\\Media\\notify.wav').PlaySync();"])
        elif sys.platform == 'darwin':
            # No macOS, usa o comando afplay
            subprocess.Popen(['afplay', '/System/Library/Sounds/Ping.aiff'])
    except Exception as e:
        print(f"Erro ao tocar som: {e}")

def open_file(path):
    """Abre um arquivo com o aplicativo padrão"""
    try:
        if sys.platform == 'win32':
            os.startfile(path)
        elif sys.platform == 'darwin':
            subprocess.Popen(['open', path])
        else:
            subprocess.Popen(['xdg-open', path])
        return True
    except Exception as e:
        print(f"Erro ao abrir arquivo: {e}")
        return False

def fetch_video_thumbnail(url, callback):
    """Busca a miniatura de um vídeo"""
    def _fetch_thumbnail():
        try:
            import yt_dlp
            with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
                info = ydl.extract_info(url, download=False)
                thumbnails = info.get('thumbnails', [])

                # Procura por uma miniatura de tamanho adequado
                thumb_url = None
                for thumb in thumbnails:
                    # Prefere miniaturas médias
                    if thumb.get('height', 0) >= 120 and thumb.get('height', 0) <= 480:
                        thumb_url = thumb.get('url')
                        break

                # Se não encontrou uma no tamanho adequado, usa a primeira
                if not thumb_url and thumbnails:
                    thumb_url = thumbnails[0].get('url')

                # Baixa a miniatura para um arquivo temporário
                if thumb_url:
                    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')
                    temp_file.close()

                    import urllib.request
                    urllib.request.urlretrieve(thumb_url, temp_file.name)

                    # Chama o callback na thread principal
                    GLib.idle_add(lambda: callback(temp_file.name) and False)
                    return

            # Se chegou aqui, não conseguiu obter a miniatura
            GLib.idle_add(lambda: callback(None) and False)

        except Exception as e:
            print(f"Erro ao buscar miniatura: {e}")
            GLib.idle_add(lambda: callback(None) and False)

    # Executa em uma thread separada
    thread = threading.Thread(target=_fetch_thumbnail)
    thread.daemon = True
    thread.start()

    return thread

# Módulo download_manager.py
"""
Gerenciamento de downloads de vídeos
"""
import os
import threading
import subprocess
import json
from datetime import datetime
import gi

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import GLib

import yt_dlp
from bigtube.utils import DownloadLogger, sanitize_filename, generate_unique_filename, check_disk_space, play_notification_sound

class DownloadItem:
    """Representa um item de download com todos os seus dados"""

    def __init__(self, url, download_dir, options=None):
        self.url = url
        self.download_dir = download_dir
        self.options = options or {}
        self.id = f"download_{datetime.now().strftime('%Y%m%d%H%M%S')}"
        self.title = "Download pendente"
        self.output_file = None
        self.cancelled = False
        self.completed = False
        self.error = None
        self.progress = 0.0
        self.status = "Pendente"
        self.start_time = None
        self.end_time = None
        self.ydl = None  # Referência ao objeto YoutubeDL

    def to_dict(self):
        """Converte o item para um dicionário"""
        return {
            'id': self.id,
            'url': self.url,
            'title': self.title,
            'output_file': self.output_file,
            'completed': self.completed,
            'error': self.error,
            'progress': self.progress,
            'status': self.status,
            'start_time': self.start_time.isoformat() if self.start_time else None,
            'end_time': self.end_time.isoformat() if self.end_time else None
        }

    @classmethod
    def from_dict(cls, data, download_dir):
        """Cria um item a partir de um dicionário"""
        item = cls(data['url'], download_dir)
        item.id = data['id']
        item.title = data['title']
        item.output_file = data['output_file']
        item.completed = data['completed']
        item.error = data['error']
        item.progress = data['progress']
        item.status = data['status']

        if data['start_time']:
            item.start_time = datetime.fromisoformat(data['start_time'])
        if data['end_time']:
            item.end_time = datetime.fromisoformat(data['end_time'])

        return item

class DownloadManager:
    """Gerencia os downloads de vídeos"""

    def __init__(self, config):
        self.config = config
        self.active_downloads = []  # Downloads ativos
        self.download_history = []  # Histórico de downloads
        self.download_threads = []  # Threads de download
        self.callbacks = {
            'progress_update': [],
            'download_complete': [],
            'download_error': [],
            'download_start': []
        }

        # Carrega o histórico de downloads
        self.load_history()

    def add_callback(self, event_type, callback):
        """Adiciona um callback para um tipo de evento"""
        if event_type in self.callbacks:
            self.callbacks[event_type].append(callback)

    def remove_callback(self, event_type, callback):
        """Remove um callback"""
        if event_type in self.callbacks and callback in self.callbacks[event_type]:
            self.callbacks[event_type].remove(callback)

    def _trigger_callbacks(self, event_type, *args):
        """Dispara todos os callbacks para um tipo de evento"""
        for callback in self.callbacks.get(event_type, []):
            callback(*args)

    def load_history(self):
        """Carrega o histórico de downloads"""
        history_file = os.path.join(
            os.path.expanduser("~"),
            ".config",
            "bigtube",
            "download_history.json"
        )

        if os.path.exists(history_file):
            try:
                with open(history_file, 'r') as f:
                    history_data = json.load(f)

                for item_data in history_data:
                    item = DownloadItem.from_dict(item_data, self.config['download_dir'])
                    self.download_history.append(item)
            except Exception as e:
                print(f"Erro ao carregar histórico: {e}")

    def save_history(self):
        """Salva o histórico de downloads"""
        history_file = os.path.join(
            os.path.expanduser("~"),
            ".config",
            "bigtube",
            "download_history.json"
        )

        # Garante que o diretório existe
        os.makedirs(os.path.dirname(history_file), exist_ok=True)

        try:
            history_data = [item.to_dict() for item in self.download_history]
            with open(history_file, 'w') as f:
                json.dump(history_data, f, indent=2)
        except Exception as e:
            print(f"Erro ao salvar histórico: {e}")

    def start_download(self, url, download_row, audio_only=False, file_format="mp4", quality="Melhor"):
        """Inicia um download de vídeo"""
        # Cria um novo item de download
        download_item = DownloadItem(url, self.config['download_dir'], {
            'audio_only': audio_only,
            'format': file_format,
            'quality': quality
        })

        # Adiciona aos downloads ativos
        self.active_downloads.append(download_item)

        # Verifica espaço em disco
        if not check_disk_space(self.config['download_dir']):
            error_msg = "Espaço em disco insuficiente para o download."
            GLib.idle_add(self._download_error, download_item, download_row, error_msg)
            return

        # Iniciar o download em uma thread separada
        thread = threading.Thread(
            target=self._download_video_thread,
            args=(download_item, download_row)
        )
        thread.daemon = True
        self.download_threads.append(thread)
        thread.start()

        # Notifica os callbacks
        self._trigger_callbacks('download_start', download_item)

        return download_item

    def cancel_download(self, download_item, download_row):
        """Cancela um download em andamento"""
        if download_item in self.active_downloads and not download_item.completed:
            download_item.cancelled = True
            GLib.idle_add(self.update_download_progress,
                         download_item, download_row, 0.0,
                         "Cancelando download...")

            # Tenta interromper o yt-dlp
            if download_item.ydl:
                try:
                    # yt-dlp não tem um método direto para interromper,
                    # mas podemos tentar forçar uma exceção
                    download_item.ydl._finish_multiline_status()
                except:
                    pass

    def clean_finished_threads(self):
        """Remove threads que já terminaram"""
        self.download_threads = [t for t in self.download_threads if t.is_alive()]

    def update_download_progress(self, download_item, download_row, fraction, status_text):
        """Atualiza o progresso do download na UI"""
        download_item.progress = fraction
        download_item.status = status_text

        # Atualiza a UI
        download_row.progress_bar.set_fraction(fraction)
        download_row.status_label.set_text(status_text)

        # Notifica callbacks
        self._trigger_callbacks('progress_update', download_item)

        return False  # Remove da fila de idle

    def _download_finished(self, download_item, download_row, output_file):
        """Chamado quando um download é concluído"""
        download_item.completed = True
        download_item.output_file = output_file
        download_item.progress = 1.0
        download_item.status = f"Download concluído: {os.path.basename(output_file)}"
        download_item.end_time = datetime.now()

        # Atualiza a UI
        download_row.progress_bar.set_fraction(1.0)
        download_row.status_label.set_text(download_item.status)
        download_row.play_button.set_sensitive(True)
        download_row.cancel_button.set_sensitive(False)

        # Toca som de notificação
        if self.config['notify_sound']:
            play_notification_sound()

        # Adiciona ao histórico
        if download_item not in self.download_history:
            self.download_history.append(download_item)
            self.save_history()

        # Remove dos downloads ativos
        if download_item in self.active_downloads:
            self.active_downloads.remove(download_item)

        # Notifica callbacks
        self._trigger_callbacks('download_complete', download_item)

        # Limpa threads finalizadas
        self.clean_finished_threads()

        return False

    def _download_error(self, download_item, download_row, error_message):
        """Chamado quando ocorre um erro no download"""
        download_item.error = error_message
        download_item.status = f"Erro: {error_message}"
        download_item.end_time = datetime.now()

        # Atualiza a UI
        download_row.progress_bar.add_css_class("error")
        download_row.status_label.set_text(download_item.status)
        download_row.cancel_button.set_sensitive(False)

        # Adiciona ao histórico
        if download_item not in self.download_history:
            self.download_history.append(download_item)
            self.save_history()

        # Remove dos downloads ativos
        if download_item in self.active_downloads:
            self.active_downloads.remove(download_item)

        # Notifica callbacks
        self._trigger_callbacks('download_error', download_item, error_message)

        # Limpa threads finalizadas
        self.clean_finished_threads()

        return False

    def _download_cancelled(self, download_item, download_row):
        """Chamado quando um download é cancelado"""
        download_item.status = "Download cancelado"
        download_item.end_time = datetime.now()

        # Atualiza a UI
        download_row.progress_bar.set_fraction(0.0)
        download_row.status_label.set_text(download_item.status)
        download_row.cancel_button.set_sensitive(False)

        # Adiciona ao histórico
        if download_item not in self.download_history:
            self.download_history.append(download_item)
            self.save_history()

        # Remove dos downloads ativos
        if download_item in self.active_downloads:
            self.active_downloads.remove(download_item)

        # Limpa threads finalizadas
        self.clean_finished_threads()

        return False

    def _download_progress_hook(self, download_item, download_row):
        """Hook para atualizar o progresso do download"""
        def hook(d):
            if download_item.cancelled:
                GLib.idle_add(self._download_cancelled, download_item, download_row)
                return

            if d['status'] == 'downloading':
                # Extrair dados do progresso
                try:
                    downloaded = d.get('downloaded_bytes', 0)
                    total = d.get('total_bytes', 0)
                    if total == 0:
                        total = d.get('total_bytes_estimate', 0)

                    if total > 0:
                        percent = downloaded / total
                        speed = d.get('speed', 0)
                        eta = d.get('eta', 0)

                        if speed:
                            speed_str = f"{speed/1024/1024:.2f} MB/s"
                        else:
                            speed_str = "-- MB/s"

                        if eta:
                            eta_str = f"{eta} segundos"
                        else:
                            eta_str = "-- segundos"

                        status_text = f"Baixando... {percent*100:.1f}% ({speed_str}, ETA: {eta_str})"
                        GLib.idle_add(self.update_download_progress, download_item, download_row, percent, status_text)
                    else:
                        # Sem informação de tamanho total, mostrar bytes baixados
                        mb_downloaded = downloaded / 1024 / 1024
                        status_text = f"Baixando... {mb_downloaded:.2f} MB"
                        # Aqui usamos um indicador de progresso indeterminado
                        GLib.idle_add(self.update_download_progress, download_item, download_row, 0.0, status_text)
                        # Fazemos a barra pulsar
                        download_row.progress_bar.pulse()

                except Exception as e:
                    print(f"Erro ao processar progresso: {e}")

            elif d['status'] == 'finished':
                GLib.idle_add(self.update_download_progress, download_item, download_row, 1.0, "Processando vídeo...")

            elif d['status'] == 'error':
                error_msg = d.get('error', 'Erro desconhecido')
                GLib.idle_add(self._download_error, download_item, download_row, error_msg)

        return hook

    def _download_video_thread(self, download_item, download_row):
        """Download real do vídeo usando yt-dlp"""
        download_item.start_time = datetime.now()

        try:
            # Configuração do logger para capturar o progresso
            logger = DownloadLogger()

            # Função para atualizar o progresso na UI
            def progress_hook(percentage):
                GLib.idle_add(self.update_download_progress,
                              download_item, download_row, percentage/100.0,
                              f"Baixando... {percentage:.1f}%")

            def error_hook(error_msg):
                GLib.idle_add(self._download_error, download_item, download_row, error_msg)

            # Configura callbacks
            logger.callback = progress_hook
            logger.error_callback = error_hook

            # Diretório de download
            download_dir = self.config['download_dir']
            os.makedirs(download_dir, exist_ok=True)

            # Determina o formato baseado nas opções
            audio_only = download_item.options.get('audio_only', False)
            file_format = download_item.options.get('format', 'mp4')
            quality = download_item.options.get('quality', 'Melhor')

            if audio_only:
                # Para somente áudio, usamos M4A ou MP3
                format_str = 'bestaudio[ext=m4a]/bestaudio/best'
                postprocessors = [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }]
            else:
                # Para vídeo, escolhemos baseado na qualidade
                if quality == "Melhor":
                    format_str = f'bestvideo[ext={file_format}]+bestaudio/best[ext={file_format}]/best'
                else:
                    # Remove o 'p' de '1080p', etc.
                    res = quality.rstrip('p')
                    format_str = f'bestvideo[height<={res}][ext={file_format}]+bestaudio/best[height<={res}][ext={file_format}]/best'

                postprocessors = [{
                    'key': 'FFmpegVideoConvertor',
                    'preferedformat': file_format,
                }]

            # Opções para o yt-dlp
            ydl_opts = {
                'format': format_str,
                'outtmpl': os.path.join(download_dir, '%(title)s.%(ext)s'),
                'postprocessors': postprocessors,
                'logger': logger,
                'progress_hooks': [self._download_progress_hook(download_item, download_row)],
                'noplaylist': True,  # Não baixar playlists inteiras
                'quiet': True,       # Minimizar saída no terminal
            }

            # Armazena referência para possível cancelamento
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                download_item.ydl = ydl

                # Verificar se já foi cancelado
                if download_item.cancelled:
                    GLib.idle_add(self._download_cancelled, download_item, download_row)
                    return

                # Obter informações do vídeo
                GLib.idle_add(self.update_download_progress,
                              download_item, download_row, 0.0,
                              "Obtendo informações do vídeo...")

                info = ydl.extract_info(download_item.url, download=False)
                video_title = info.get('title', 'Vídeo')

                # Sanitiza o título para uso como nome de arquivo
                safe_title = sanitize_filename(video_title)
                download_item.title = video_title

                # Atualiza o título da linha de download
                GLib.idle_add(lambda: download_row.set_title(f"Download: {video_title}"))

                # Iniciar download
                if not download_item.cancelled:
                    GLib.idle_add(self.update_download_progress,
                                  download_item, download_row, 0.05,
                                  "Download iniciado...")

                    # Fazer o download real
                    ydl.download([download_item.url])

                    # Determinar o arquivo final
                    file_ext = 'mp3' if audio_only else file_format
                    expected_filename = f"{safe_title}.{file_ext}"

                    # Caminho completo do arquivo
                    output_file = os.path.join(download_dir, expected_filename)

                    # Verificar se o arquivo foi criado
                    if not os.path.exists(output_file):
                        # Procurar qualquer arquivo que comece com o título
                        for file in os.listdir(download_dir):
                            if file.startswith(safe_title[:20]):  # Usa parte do título para comparação
                                output_file = os.path.join(download_dir, file)
                                break

                    # Se ainda não encontrou, gerar um nome único
                    if not os.path.exists(output_file):
                        output_file = generate_unique_filename(download_dir, safe_title, file_ext)

                    download_item.output_file = output_file

                    if not download_item.cancelled:
                        GLib.idle_add(self._download_finished, download_item, download_row, output_file)
                    else:
                        GLib.idle_add(self._download_cancelled, download_item, download_row)

        except Exception as e:
            import traceback
            traceback.print_exc()
            GLib.idle_add(self._download_error, download_item, download_row, str(e))

# Módulo settings.py
"""
Gerenciamento de configurações para o aplicativo
"""
import os
import json
from pathlib import Path

class Settings:
    """Gerencia as configurações do aplicativo"""

    def __init__(self):
        # Configurações padrão
        self.defaults = {
            'download_dir': str(Path.home() / "Downloads"),
            'default_format': "mp4",
            'preferred_player': "",
            'notify_sound': True,
            'max_downloads': 3,
            'keep_history': True,
            'dark_mode': True,
            'remember_window_size': True,
            'window_width': 800,
            'window_height': 600,
            'autostart_download': True,
            'preview_thumbnail': True,
            'save_location_remember': True,
            'always_ask_location': False,
            'close_to_tray': False,
            'language': "auto"
        }

        # Caminho para o arquivo de configuração
        self.config_dir = os.path.join(os.path.expanduser("~"), ".config", "bigtube")
        self.config_file = os.path.join(self.config_dir, "settings.json")

        # Configurações atuais
        self.config = self.defaults.copy()

        # Carregar configurações salvas
        self.load()

    def load(self):
        """Carrega as configurações do arquivo"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Atualiza as configurações com os valores carregados
                    self.config.update(loaded_config)
        except Exception as e:
            print(f"Erro ao carregar configurações: {e}")

    def save(self):
        """Salva as configurações no arquivo"""
        try:
            # Garante que o diretório existe
            os.makedirs(self.config_dir, exist_ok=True)

            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)

            return True
        except Exception as e:
            print(f"Erro ao salvar configurações: {e}")
            return False

    def get(self, key, default=None):
        """Obtém um valor de configuração"""
        return self.config.get(key, default)

    def set(self, key, value):
        """Define um valor de configuração"""
        self.config[key] = value

    def reset(self):
        """Redefine todas as configurações para os valores padrão"""
        self.config = self.defaults.copy()

    def reset_key(self, key):
        """Redefine uma configuração específica para o valor padrão"""
        if key in self.defaults:
            self.config[key] = self.defaults[key]
